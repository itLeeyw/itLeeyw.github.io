<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="LeeywBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LeeywBlog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeeywBlog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>LeeywBlog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LeeywBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的学习笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/why-useing-clearfix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/why-useing-clearfix/" itemprop="url">解决CSS的定位方案！(clearfix)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-29T20:44:55+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="一般我们使用那些定位？"><a href="#一般我们使用那些定位？" class="headerlink" title="一般我们使用那些定位？"></a>一般我们使用那些定位？</h2><h4 id="1-staic-普通定位流-默认"><a href="#1-staic-普通定位流-默认" class="headerlink" title="1. staic(普通定位流/默认)"></a>1. staic(普通定位流/默认)</h4><ul>
<li>block || inline 从上到下 || 从左到右排列布局</li>
</ul>
<h4 id="2-float-浮动定位"><a href="#2-float-浮动定位" class="headerlink" title="2. float(浮动定位)"></a>2. float(浮动定位)</h4><ul>
<li>value：(none/left/right)</li>
<li>会脱离文档流，但仍然属于父元素</li>
</ul>
<h4 id="3-position"><a href="#3-position" class="headerlink" title="3. position"></a>3. position</h4><ul>
<li><p>value：(relative/absolute/fixed/sticky)</p>
<blockquote>
<p>relative</p>
<blockquote>
<p>相对原位置偏移某些距离，但仍然占据原位置的空间<br>不脱离文档流(或许?,因为偏移了以后仍然占据原空间)</p>
</blockquote>
</blockquote>
<blockquote>
<p>absolute</p>
<blockquote>
<p>寻找父元素的relative，一直向上找青蛙，直到(html/body)<br>脱离文档流</p>
</blockquote>
</blockquote>
<blockquote>
<p>fixed</p>
<blockquote>
<p>将element固定在窗口的某个相对位置，不随着滚动条的位置变化而变化<br>脱离文档流</p>
</blockquote>
</blockquote>
<h2 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h2><h4 id="0-浮动定位解决的问题多个块级元素在同一行显示"><a href="#0-浮动定位解决的问题多个块级元素在同一行显示" class="headerlink" title="0. 浮动定位解决的问题多个块级元素在同一行显示"></a>0. 浮动定位解决的问题多个块级元素在同一行显示</h4><h4 id="1-block-element允许修改尺寸，inline-不允许修改尺寸"><a href="#1-block-element允许修改尺寸，inline-不允许修改尺寸" class="headerlink" title="1. block element允许修改尺寸，inline 不允许修改尺寸"></a>1. block element允许修改尺寸，inline 不允许修改尺寸</h4><h4 id="2-若“一行”内显示不下所有float内容last-element则会换行"><a href="#2-若“一行”内显示不下所有float内容last-element则会换行" class="headerlink" title="2. 若“一行”内显示不下所有float内容last element则会换行"></a>2. 若“一行”内显示不下所有float内容last element则会换行</h4><h4 id="3-block-or-inline-or-inline-block-再浮动后都会变成block"><a href="#3-block-or-inline-or-inline-block-再浮动后都会变成block" class="headerlink" title="3. block or inline or inline-block 再浮动后都会变成block"></a>3. block or inline or inline-block 再浮动后都会变成block</h4><hr>
<h1 id="正片-如何清除浮动-or-闭合浮动？"><a href="#正片-如何清除浮动-or-闭合浮动？" class="headerlink" title="正片! 如何清除浮动 or 闭合浮动？"></a>正片! 如何清除浮动 or 闭合浮动？</h1><h4 id="Q-为什么浮动这么好却要-清除（闭合）浮动"><a href="#Q-为什么浮动这么好却要-清除（闭合）浮动" class="headerlink" title="Q: 为什么浮动这么好却要 清除（闭合）浮动?"></a>Q: 为什么浮动这么好却要 <del>清除</del>（闭合）浮动?</h4><h4 id="A"><a href="#A" class="headerlink" title="A:"></a>A:</h4><hr>
<h4 id="1-clear-：-译为清除，以下取值详解"><a href="#1-clear-：-译为清除，以下取值详解" class="headerlink" title="1. clear ： 译为清除，以下取值详解"></a>1. clear ： 译为清除，以下取值详解</h4><h4 id="2-闭合浮动：使浮动元素“闭合”减少浮动带来的影响"><a href="#2-闭合浮动：使浮动元素“闭合”减少浮动带来的影响" class="headerlink" title="2. 闭合浮动：使浮动元素“闭合”减少浮动带来的影响"></a>2. 闭合浮动：使浮动元素“闭合”减少浮动带来的影响</h4></li>
</ul>
<hr>
<h4 id="plan-1：给父元素添加空子元素（after），设置clear-both-简单点说就是添加额外的标签"><a href="#plan-1：给父元素添加空子元素（after），设置clear-both-简单点说就是添加额外的标签" class="headerlink" title="plan 1：给父元素添加空子元素（after），设置clear:both,简单点说就是添加额外的标签"></a>plan 1：给父元素添加空子元素（after），设置clear:both,简单点说就是添加额外的标签</h4><ul>
<li>clear:none 默认，不做任何操作</li>
<li>clear:left 清除前面元素带来的所有左浮动影响</li>
<li>clear:float 和楼上类似效果</li>
<li>clear:both 清除前面元素所有浮动带来的影响</li>
</ul>
<p><strong>优势</strong>：代码量少，易学，好懂<br><strong>劣势</strong>：推荐</p>
<pre><code>.clearfix::after{
    content: &apos;&apos;; //添加空元素
    display: block;//设置成块级元素
    clear: both;//清除前面浮动带来的所有效果
}
</code></pre><h4 id="plan-2-添加-gt-标签，通过其本身HTML特性"><a href="#plan-2-添加-gt-标签，通过其本身HTML特性" class="headerlink" title="plan 2: 添加&gt;标签，通过其本身HTML特性"></a>plan 2: 添加<br clear="both">&gt;标签，通过其本身HTML特性</h4><ul>
<li>在浮动元素的父元素下添加一个last child 标签为<br clear="both"></li>
<li>OK!</li>
<li></li>
</ul>
<p><strong>优势</strong>： 代码量更少<br><strong>劣势</strong>：同有违结构和表现的分离，不推荐</p>
<h4 id="plan-3-添加-overflow-hidden"><a href="#plan-3-添加-overflow-hidden" class="headerlink" title="plan 3:添加 overflow:hidden;"></a>plan 3:添加 overflow:hidden;</h4><ul>
<li>在浮动元素的父元素下添加CSS样式 overflow:hidden</li>
</ul>
<p><strong>优势</strong>：代码量更更少了<br><strong>劣势</strong>：内容增多会造成不会自动换行导致内容被隐藏，无法显示要溢出的内容<br>注意：(这个bug写者并没有实验出来)，但既然已经有人排过雷便少使用此方法罢。</p>
<h4 id="plan-3-添加-overflow-auto"><a href="#plan-3-添加-overflow-auto" class="headerlink" title="plan 3:添加 overflow:auto;"></a>plan 3:添加 overflow:auto;</h4><ul>
<li>在浮动元素的父元素下添加CSS样式 overflow:auto</li>
</ul>
<p><strong>优势</strong>：代码量更更更少了…<br><strong>劣势</strong>：冒失雷挺多的，不要使用</p>
<h4 id="plan-5-添加-display-table"><a href="#plan-5-添加-display-table" class="headerlink" title="plan 5:添加 display:table;"></a>plan 5:添加 display:table;</h4><ul>
<li>在浮动元素的父元素下添加CSS样式 display:table;</li>
</ul>
<p><strong>优势</strong>：代码量… 懂的<br><strong>劣势</strong>：盒模型属性改变，造成的影响可能比带来的好处要大，不推荐</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>推荐Plan 1</li>
<li><p>“闭合”浮动无非是两种方法:</p>
<blockquote>
<ol>
<li>通过在浮动元素末尾添加一个元素 然后clear:both</li>
<li>通过overflow or display:table 闭合浮动</li>
</ol>
</blockquote>
</li>
<li><p>如何理解其中原理 便看我另一篇文章《（Block formatting contexts）BFS是啥子？》</p>
</li>
</ul>
<pre><code>参考资料：
</code></pre><ul>
<li><a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="noopener">《那些年我们一起清除过的浮动》</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1438265" target="_blank" rel="noopener">《清除浮动的多种方式》</a></li>
<li><a href="https://www.w3schools.com/cssref/pr_class_clear.asp" target="_blank" rel="noopener">Css clear Property</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/CSS/float" target="_blank" rel="noopener">Css float Property</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/newPromise-async/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/23/newPromise-async/" itemprop="url">newPromise-async</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-23T21:45:57+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="new-Promise-async"><a href="#new-Promise-async" class="headerlink" title="new Promise(async)"></a>new Promise(async)</h1><h2 id="承诺执行"><a href="#承诺执行" class="headerlink" title="承诺执行"></a>承诺执行</h2><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><h2 id="async-resolve-reject"><a href="#async-resolve-reject" class="headerlink" title="async(resolve,reject){"></a>async(resolve,reject){</h2><p>//TODO<br>}</p>
<h2 id="on-resolve-data"><a href="#on-resolve-data" class="headerlink" title="on_resolve(data){"></a>on_resolve(data){</h2><p>//“成功”TODO<br>}</p>
<h2 id="on-reject-data"><a href="#on-reject-data" class="headerlink" title="on_reject(data){"></a>on_reject(data){</h2><p>//“失败”TODO<br>}</p>
<p><em>XMind: ZEN - Trial Version</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/CreateFreeCloudServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/CreateFreeCloudServer/" itemprop="url">CreateFreeCloudServer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T23:31:46+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在你的网页上创建一个免费的数据库-leancloud"><a href="#在你的网页上创建一个免费的数据库-leancloud" class="headerlink" title="在你的网页上创建一个免费的数据库(leancloud)"></a>在你的网页上创建一个免费的数据库(leancloud)</h1><h2 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1.注册账号"></a>1.<a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">注册账号</a></h2><h2 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2. 创建应用"></a>2. 创建应用</h2><h2 id="3-进入快速入门页面选择你的主要编译语言"><a href="#3-进入快速入门页面选择你的主要编译语言" class="headerlink" title="3. 进入快速入门页面选择你的主要编译语言"></a>3. 进入<a href="https://leancloud.cn/docs/start.html" target="_blank" rel="noopener">快速入门</a>页面选择你的主要编译语言</h2><h2 id="4-下载-or-引入-服务"><a href="#4-下载-or-引入-服务" class="headerlink" title="4. 下载 or 引入 服务"></a>4. 下载 or 引入 服务</h2><pre><code>&lt;script src=&quot;//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="5-init"><a href="#5-init" class="headerlink" title="5. init"></a>5. init</h2><pre><code>var APP_ID = &apos;you APP_ID&apos;;
var APP_KEY = &apos;you APP_KEY&apos;;

AV.init({
  appId: APP_ID,
  appKey: APP_KEY
});
</code></pre><h2 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h2><pre><code>ping &quot;kdqicvul.api.lncld.net&quot;

and

/.js
var TestObject = AV.Object.extend(&apos;TestObject&apos;);var testObject = new TestObject();
testObject.save({
  words: &apos;Hello World!&apos;}).then(function(object) {
  alert(&apos;LeanCloud Rocks!&apos;);})
</code></pre><h2 id="7-获取后端数据？查看API文档"><a href="#7-获取后端数据？查看API文档" class="headerlink" title="7. 获取后端数据？查看API文档"></a>7. 获取后端数据？查看API文档</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/Browser-Same-origin-policy-EvaSion-Method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/Browser-Same-origin-policy-EvaSion-Method/" itemprop="url">Browser-Same-origin-policy-EvaSion-Method</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-18T13:47:21+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器同源政策以及规避方法"><a href="#浏览器同源政策以及规避方法" class="headerlink" title="浏览器同源政策以及规避方法"></a>浏览器同源政策以及规避方法</h1><blockquote>
<p>浏览器安全的基石是”同源政策”（same-origin policy）</p>
</blockquote>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote>
<p>同源政策为Netscape公司于1995年引入浏览器。<br>目前，所有浏览器都实行这个政策</p>
</blockquote>
<h3 id="1）含义"><a href="#1）含义" class="headerlink" title="1）含义"></a>1）含义</h3><blockquote>
<p>“同源”</p>
<blockquote>
<p>A网页设置Cookie，B网页不能打开，除非“同源”</p>
</blockquote>
</blockquote>
<ul>
<li>“同源”三同：<ol>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ol>
</li>
</ul>
<blockquote>
<p>目的</p>
<blockquote>
<p>保证Client信息安全，防止被恶意窃取数据。<br>例如：<br>用户C访问网站A，用户登陆后又去访问网站B(恶意网站)，若网站B可读取A网站Cookie？</p>
<ol>
<li>B网站通过Cookie获取到用户C的信息（若Cookie包含隐私，则会隐私泄露）</li>
<li>由于Cookie往往是来保存登陆信息，若用户没有退出登陆，则网站B可以冒充用户：为所欲为。浏览器规定：提交表单不受同源政策限制<br>综上所述<br>同源政策是必须的，“同源政策”越严格，用户安全性更高，网站安全性更高。（防止Cookie共享）</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>限制范围</p>
<blockquote>
<p>若非“同源”，则 共有三种行为限制</p>
</blockquote>
</blockquote>
<ul>
<li>Cookie,LocalStorage 和 IndexDB 无法读取</li>
<li>DOM无法获得</li>
<li><p>AJAX请求无法发送</p>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下述将如何规避这些限制</p>
</li>
</ul>
<h2 id="二、Cookie"><a href="#二、Cookie" class="headerlink" title="二、Cookie"></a>二、Cookie</h2><blockquote>
<p>Cookie是Server给Browser的一段信息，只有“同源”网页才能共享 但有时同属网页下，会出现一级域名相同二级域名不同的情况？<br>不同的网页通过设置相同的document.domain来共享Cookie</p>
</blockquote>
<pre><code>document.domain = &quot;example.com&quot;
</code></pre><p>所以现在网页A通过脚本设置一个Cookie</p>
<pre><code>documenet.cookie = &quot;test = lwh&quot;
</code></pre><p> 网页B就可以读取到这个Cookie</p>
<pre><code>var allCookie = document.cookie
</code></pre><blockquote>
<p>这种方法只适用于Cookie以及iframe窗口，LocalStorage以及IndexDB无法通过这种方法，规避“同源政策”，就需要使用PostMessage API</p>
</blockquote>
<blockquote>
<p>另外：Server在设置Cookie时，指定Cookie的所属域名为y一级域名，例如，.example.com</p>
</blockquote>
<pre><code>Set-Cookie:key=value;domain=.example.com;path = /

此后下属，二/三级域名不用做任何设置都可以读取这个Cookie
</code></pre><h2 id="三、iframe"><a href="#三、iframe" class="headerlink" title="三、iframe"></a>三、iframe</h2><blockquote>
<p>两个网页不同源，则无法获取到对方DOM</p>
<blockquote>
<p>例子：<br>iframe 以及 window.open 打开的窗口都无法与父窗口通信</p>
</blockquote>
</blockquote>
<pre><code>强行访问则会报错  
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
未捕获，DOM异常：阻止了一个frame访问跨源frame

无论子访问父or父访问子的DOM 都会报错
</code></pre><blockquote>
<p>三种方法解决跨域访问的通信问题</p>
<pre><code>1. 片段识别符（fragment identifier）
2. window.name
3. 跨文档通信API(Cross-document messaging)
</code></pre></blockquote>
<ul>
<li><ol>
<li><p>片段识别符（fragment identifier）</p>
<blockquote>
<p>URL # 号后面部分例如：<br><a href="http://example.com/x.html#fragment的fragment就是偏度识别符，改变片段识别符，页面不会重新刷新" target="_blank" rel="noopener">http://example.com/x.html#fragment的fragment就是偏度识别符，改变片段识别符，页面不会重新刷新</a></p>
<blockquote>
<p>父窗口可以把信息写入子窗口的片段识别符</p>
</blockquote>
</blockquote>
<pre><code>var src = originURL + &apos;#&apos; + data;
document.getElementById(&apos;myIFrame&apos;).src = src;
</code></pre><blockquote>
<blockquote>
<p>子窗口通过 监听 hashchange 事件得到通知</p>
</blockquote>
</blockquote>
</li>
</ol>
</li>
</ul>
<pre><code>window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
</code></pre><blockquote>
<blockquote>
<p>同时，子窗口也可以改变父窗口的片段标识</p>
</blockquote>
</blockquote>
<pre><code>parent.location.href= target + &quot;#&quot; + hash;
</code></pre><ul>
<li><ol start="2">
<li><p>window.name</p>
<blockquote>
<p>Browser Window 有 window.name 属性</p>
<blockquote>
<p>window.name 特点：无论是否同源只要在同一个窗口中，前一个网页设置了这个属性，后一个网页可以读取它<br>父窗口首先打开一子窗口，载入一不同源网页，该网页将信息写入window.name属性</p>
</blockquote>
</blockquote>
<p> window.name = data;</p>
<blockquote>
<blockquote>
<p>接着，子窗口跳回一个与主窗口同域的网址</p>
</blockquote>
</blockquote>
<p> location = ‘<a href="http://parent.url.com/xxx.html&#39;" target="_blank" rel="noopener">http://parent.url.com/xxx.html&#39;</a>;</p>
</li>
</ol>
<blockquote>
<blockquote>
<p>然后，主窗口就可以读取子窗口的window.name了</p>
</blockquote>
</blockquote>
</li>
</ul>
<pre><code>    var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name;
&gt; 优点:window.name 容量很大，可以放置非常长的字符串，缺点是必须监听window.name属性变化影响网页性能
</code></pre><ul>
<li><ol start="3">
<li>postMessage<blockquote>
<p>上面两种办法属于破解，这种办法是HTML5为了解决这个问题，引入的一个新API:跨文档通信API(Cross-Document Message )</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<pre><code>&gt; 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。

    var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);
    popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);
&gt; postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即&quot;协议 + 域名 + 端口&quot;。也可以设为*，表示不限制域名，向所有窗口发送。


&gt;子窗口向父窗口发送消息的写法类似。

    window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);
&gt; 父窗口和子窗口都可以通过message事件，监听对方的消息。

    window.addEventListener(&apos;message&apos;, function(e) {
      console.log(e.data);
      },false);


&gt; message事件的事件对象event，提供以下三个属性。

  * event.source：发送消息的窗口
  * event.origin: 消息发向的网址
  * event.data: 消息内容
&gt;  event.origin属性可以过滤不是发给本窗口的消息。


    window.addEventListener(&apos;message&apos;, receiveMessage);function receiveMessage(event) {
      if (event.origin !== &apos;http://aaa.com&apos;) return;
      if (event.data === &apos;Hello World&apos;) {
          event.source.postMessage(&apos;Hello&apos;, event.origin);
      } else {
        console.log(event.data);
      }}
</code></pre><ul>
<li><ol start="4">
<li><p>LocalStorage </p>
<blockquote>
<p>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。下面是一个例子，主窗口写入iframe子窗口的localStorage。</p>
</blockquote>
<p> window.onmessage = function(e) {<br>   if (e.origin !== ‘<a href="http://bbb.com&#39;" target="_blank" rel="noopener">http://bbb.com&#39;</a>) {</p>
<pre><code>return;
</code></pre><p>   }<br>   var payload = JSON.parse(e.data);<br>   localStorage.setItem(payload.key, JSON.stringify(payload.data));};</p>
</li>
</ol>
<blockquote>
<p> 上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。</p>
</blockquote>
</li>
</ul>
<h3 id="四、AJAX"><a href="#四、AJAX" class="headerlink" title="四、AJAX"></a>四、AJAX</h3><blockquote>
<p> 同源政策规定，AJAX只能请求同源网址，否则报错</p>
</blockquote>
<blockquote>
<p>除了架设服务器代理(Browser request 同源Server，再由后者request 外部服务)，有三种办法规避这个限制</p>
</blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<blockquote>
<ol>
<li>JSONP  <blockquote>
<p>JSONP是Server于Client跨源通信的常用方法<br>特点：简单适用，老式Browser全部支持，服务器改动较小<br>它的基本思想是，网页通过添加一个<script>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。<br>首先，网页动态插入<script>元素，由它向跨源网址发出请求。</p>
</blockquote>
</li>
</ol>
</blockquote>
<pre><code>function addScriptTag(src) {
  var script = document.createElement(&apos;script&apos;);
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);}

window.onload = function () {
  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);}

function foo(data) {
  console.log(&apos;Your public IP address is: &apos; + data.ip);
</code></pre><blockquote>
<p>上面代码通过动态添加<script>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
</blockquote>
<blockquote>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
</blockquote>
<pre><code>foo({
  &quot;ip&quot;: &quot;8.8.8.8&quot;
  });
</code></pre><blockquote>
<p>由于<script>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p>
</blockquote>
<ul>
<li><ol start="2">
<li><p>WebSocket</p>
<blockquote>
<p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。<br>例子，浏览器发出的WebSocket请求头信息：</p>
</blockquote>
<p>   GET /chat HTTP/1.1<br>   Host: server.example.com<br>   Upgrade: websocket<br>   Connection: Upgrade<br>   Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==<br>   Sec-WebSocket-Protocol: chat, superchat<br>   Sec-WebSocket-Version: 13<br>   Origin: <a href="http://example.com">http://example.com</a></p>
<blockquote>
<p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
</blockquote>
<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept:     HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><ul>
<li><ol start="3">
<li>CORS(Cross-Origin Resource Sharing):跨域资源分享<blockquote>
<p>W3C标准，是跨域AJAX请求的根本解决方案，相比JSONP只能发送GET 请求，CORS允许任何类型的请求。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">阮一峰：浏览器同源政策及其规避方法</a></p>
</script></p></blockquote></li></ol></blockquote>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/HTTP-StatusCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/HTTP-StatusCode/" itemprop="url">HTTP-StatusCode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T20:58:28+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP　状态码"></a>HTTP　状态码</h2><blockquote>
<p>　Ｓｔａｔｕｓ－ｃｏｄｅ为服务器的返回值，是用３个数字来表示，第一个数字是作为状态码的分类，后两位数字只做类别再次细分不做大类分别</p>
</blockquote>
<ol>
<li><p>1XX:信息(Informational)</p>
<blockquote>
<p>请求已经收到，请求过程正在继续</p>
</blockquote>
<ul>
<li><p>100 Continue</p>
<blockquote>
<p>Client 应当继续等待请求，这个是Server端的临时状态，用于通知服务端</p>
</blockquote>
</li>
<li><p>101 Switching Protocols</p>
<blockquote>
<p>请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>2XX:成功(Success)</p>
<blockquote>
<p>请求成功，被服务器理解并允许访问</p>
</blockquote>
<ul>
<li><p>200 OK</p>
<blockquote>
<p>服务器已成功处理了请求，表示服务器提供了被请求的网页。</p>
</blockquote>
</li>
<li><p>201 Create</p>
<blockquote>
<p>请求成功并且创建了新的资源</p>
</blockquote>
</li>
<li><p>202 Accepted</p>
<blockquote>
<p>Server已接受请求，但尚未处理，也可能请求的是Server有意拒绝的服务，导致请求失败。</p>
</blockquote>
</li>
<li><p>204 No Content</p>
<blockquote>
<p>请求到了 但服务器没有返回内容</p>
</blockquote>
</li>
</ul>
</li>
<li><p>3XX:重定向(Readirecion)</p>
<blockquote>
<p>必须进一步的采取行动操作才能完成请求</p>
</blockquote>
<ul>
<li>304 Not Modified<blockquote>
<p>表示请求后但资源暂未被修改</p>
</blockquote>
</li>
</ul>
</li>
<li><p>4XX:客户端错误(Client Error)</p>
<blockquote>
<p>请求失败，语法错误或某些操作无法完成</p>
</blockquote>
<ul>
<li><p>400 Bad Request</p>
<blockquote>
<p>请求过程中，语法格式错误(域验证错误，缺少数据等</p>
</blockquote>
</li>
<li><p>401 Unauthorized </p>
<blockquote>
<p> 没有被授权访问，需要用户身份验证，与403 Forbidden类似，但特别适用于可能进行身份验证但已失败或尚未提供的情况。响应必须包含WWW-Authenticate头字段，其中包含适用于所请求资源的讯息</p>
</blockquote>
</li>
<li><p>403 Forbidden</p>
<blockquote>
<p>服务器理解请求(请求合法)，但拒绝。与401不同的是这与授权验证无关，若不希望将此页面信息交给用户，则可以使用404status code</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<pre><code>*  404 Not Found
    &gt; 服务器没有找到Requests-URI匹配的任何内容，不确定是永久性或是暂时性，服务器可以通过一些配置告知客户端旧资源是不可见且无重定向地址，则我们可以使用410(Gone)状态码
    &gt; 
    &gt; 服务器若不希望确切说明请求被拒绝原因时或没有其他相应适用的时候常用此状态码 
</code></pre><ul>
<li>409 Conflict<blockquote>
<p>服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</p>
</blockquote>
</li>
</ul>
<ol start="5">
<li><p>5XX:服务器错误(Server Error)</p>
<blockquote>
<p>服务器并未能完成一个明显(合法)的请求</p>
</blockquote>
<ul>
<li>500 Internal Server Error<blockquote>
<p>  服务器内部错误）  服务器遇到错误，无法完成请求。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.restapitutorial.com/httpstatuscodes.html" target="_blank" rel="noopener">参考1</a><br><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">维基百科</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/js-call-apply-bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/js-call-apply-bind/" itemprop="url">js-call-apply-bind</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T11:25:54+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Javascript-call-apply-bind-的用法"><a href="#Javascript-call-apply-bind-的用法" class="headerlink" title="Javascript call() apply() bind()的用法"></a>Javascript call() apply() bind()的用法</h2><blockquote>
<p>ECMScript规范给所有函数都定义了call和apply两个方法，他们的应用广泛，作用一样，只是参数列表传参形式不同</p>
</blockquote>
<ul>
<li><p>call()  </p>
<blockquote>
<p>指定一个this,并给出一个或多个参数来调用一个函数(function)<br>与apply（）方法类似，但call()接受的是一个参数列表，而apply()接受的是一个包含多个参数的数组</p>
</blockquote>
<pre><code>//apply的用法
var obj = {
    name : &apos;linxin&apos;
}

function func(firstName, lastName){
    console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);
}

func.apply(obj, [&apos;A&apos;, &apos;B&apos;]);    // A linxin B
* obj作为函数上下文的对象函数func中 this指向这个对象，在默认情况下this指向的为全局对象
//call的用法    
var obj = {
    name: &apos;linxin&apos;
}

function func(firstName, lastName) {
    console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);
}

func.call(obj, &apos;C&apos;, &apos;D&apos;);       // C linxin D
</code></pre></li>
</ul>
<h3 id="apply和call的用法？"><a href="#apply和call的用法？" class="headerlink" title="apply和call的用法？"></a>apply和call的用法？</h3><ol>
<li>改变this的指向</li>
</ol>
<pre><code>     var obj = {
         name: &apos;linxin&apos;
     }

     function func() {
         console.log(this.name);
     }

     func.call(obj); 

     等同于
      function func() {
         console.log(obj.name);
     }
&gt; 我们知道了call第一个参数为函数上下文的对象，这里将obj传递给了func，此时函数里的this便指向了obj
</code></pre><ol start="2">
<li><p>借用别的对象的方法</p>
<pre><code>var Person1  = function () {
    this.name = &apos;linxin&apos;;
}
var Person2 = function () {
    this.getname = function () {
        console.log(this.name);
    }
    Person1.call(this);
}
var person = new Person2();
person.getname();       // linxin
</code></pre><blockquote>
<p>在实例化的person使用getname() 获取到了Person1的name.</p>
<p>我们注意到Person2中将当前上下文的this传递到了Person1中，所以此时Person1的this指向的是Person2的this，于是Person1中，this.name = ‘linxin’ 等同于 Person2中 name = ‘linxin’，所以等同于Person2能继承Person1中的所有属性以及方法，等于Person2继承了Person1</p>
</blockquote>
<ol start="3">
<li><p>调用函数(call()和apply()都会让函数立即执行，所以可做为调用函数的方法)</p>
<p>function func() {<br>   console.log(‘linxin’);<br>}<br>func.call();            // linxin</p>
</li>
</ol>
</li>
</ol>
<h3 id="call-与bind-的区别？"><a href="#call-与bind-的区别？" class="headerlink" title="call()与bind()的区别？"></a>call()与bind()的区别？</h3><blockquote>
<p>bind()为ECMScript5中扩展的新方法，所以一些老版本的浏览器(IE低版本)无法兼容，它和call类似，接收的参数与call()相同，第一个为函数上下文，第二个是参数列表，可以接受多个参数</p>
</blockquote>
<h4 id="他们之间有两个区别"><a href="#他们之间有两个区别" class="headerlink" title="他们之间有两个区别"></a>他们之间有两个区别</h4><ol>
<li><p>bind发返回值是函数</p>
<pre><code>var obj = {
    name: &apos;linxin&apos;
}

function func() {
    console.log(this.name);
}

var func1 = func.bind(obj);
func1();                        // linxin
</code></pre><blockquote>
<p>bind方法不会立刻执行，其中，它会返回一个改变过上下文this的函数，而原函数不会改变，原函数的this依然指向window</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>参数的使用</p>
<pre><code>function func(a, b, c) {
    console.log(a, b, c);
}
var func1 = func.bind(null,&apos;linxin&apos;);

func(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;);            // A B C
func1(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;);           // linxin A B
func1(&apos;B&apos;, &apos;C&apos;);                // linxin B C
func.call(null, &apos;linxin&apos;);      // linxin undefined undefined
</code></pre><blockquote>
<p>其中返回过后的函数会以bind参数为基础，后面调用这个bind返回的函数会将参数往后排</p>
</blockquote>
</li>
</ol>
<h3 id="若低版本的ie无法兼容bind则可以自己写一个"><a href="#若低版本的ie无法兼容bind则可以自己写一个" class="headerlink" title="若低版本的ie无法兼容bind则可以自己写一个"></a>若低版本的ie无法兼容bind则可以自己写一个</h3><pre><code>if (!Function.prototype.bind) {//若没有bind函数
        Function.prototype.bind = function () {//在在function的原型中添加一个bind方法
            var self = this,                        // 保存原函数
                context = [].shift.call(arguments), // 保存需要绑定的this上下文
                args = [].slice.call(arguments);    // 剩余的参数转为数组
            return function () {                    // 返回一个新函数
                self.apply(context,[].concat.call(args, [].slice.call(arguments)));
            }
        }
    }
</code></pre><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://github.com/lin-xin/blog/issues/7" target="_blank" rel="noopener">参考1</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind参考</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call参考</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/js-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/js-closure/" itemprop="url">js-closure</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-15T23:31:16+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="理解JavaScript闭包？"><a href="#理解JavaScript闭包？" class="headerlink" title="理解JavaScript闭包？"></a>理解JavaScript闭包？</h1><h2 id="首先理解变量的作用域"><a href="#首先理解变量的作用域" class="headerlink" title="首先理解变量的作用域"></a>首先理解变量的作用域</h2><blockquote>
<p>变量的作用域无非两种</p>
</blockquote>
<ul>
<li>全局变量  global</li>
<li>局部变量  local</li>
</ul>
<h3 id="tips-里提到一个小知识"><a href="#tips-里提到一个小知识" class="headerlink" title="tips: 里提到一个小知识"></a>tips: 里提到一个小知识</h3><pre><code>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。
使用let声明的变量，其作用域为该语句所在的函数代码块内，不存在变量提升的现象
使用const声明的是常量，在后面出现的代码中不能再修改该常量的值
</code></pre><blockquote>
<ol>
<li><p>而JavaScript的语法中，函数内部可以直接读取全局变量</p>
</li>
<li><p>另一方面，函数外部自然无法读取函数内部的局部变量</p>
</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li><u>需要注意的是，函数内部声明变量的时候，一定要使用var命令，如果不用的话，你实际上是声明了一个全局变量</u></li>
</ul>
</blockquote>
<pre><code>function f1(){
   n=999;
 }　　
 f1();　　
 alert(n); // 999
</code></pre><h2 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h2><blockquote>
<p>由于项目需求，我们可能需要得到函数内的局部变量，但是在正常情况下这是做不到的。所以只能通过变通的方法实现。</p>
</blockquote>
<blockquote>
<p>在函数的内部再定义一个函数</p>
</blockquote>
<pre><code>function f1(){

     var n=999;

     function f2(){
       alert(n); // 999
     }

   }
</code></pre><blockquote>
<p>上面是一个标准的JavaScript特有的 <strong>“链式作用域”</strong> 结构chain scope） ，子对象会一级一级的向父级对象寻找所有的变量       </p>
</blockquote>
<ul>
<li><p>既然f2可以读取到f1的变量，辣么，只要把f2作为返回值，我们不久可以再外部读取它的内部变量的吗？</p>
<pre><code>function f1(){
  var n=999;
  function f2(){
    alert(n); 
  }　　　　
  return f2;
  }　　
  var result=f1();
  result(); // 999
</code></pre></li>
</ul>
<h3 id="闭包的概念。"><a href="#闭包的概念。" class="headerlink" title="闭包的概念。"></a>闭包的概念。</h3><blockquote>
<ol>
<li>f2 就是闭包</li>
<li>闭包：能读取其他函数内部(局部)变量的函数</li>
<li>JavaScript中，只有函数内部的子函数能读取到局部变量，所以可以把闭包理解为：定义在函数内部的函数</li>
<li>闭包是函数内部以及外部链接的桥梁</li>
</ol>
</blockquote>
<h3 id="闭包的作用？"><a href="#闭包的作用？" class="headerlink" title="闭包的作用？"></a>闭包的作用？</h3><blockquote>
<ol>
<li>可以读取函数内部的变量</li>
<li>让这些变量的值始终保持在内存中。</li>
</ol>
</blockquote>
<pre><code>function f1(){
  var n=999;　　　
  nAdd=function(){
  n+=1
    }　　　　
  function f2(){
      alert(n);
  }　　　　
 return f2;　
 }　　
var result=f1();　　
result(); // 999　
nAdd();　　
result(); // 10000
</code></pre><h3 id="闭包的运行逻辑-个人理解，并不确定是否正确：路子野"><a href="#闭包的运行逻辑-个人理解，并不确定是否正确：路子野" class="headerlink" title="闭包的运行逻辑(个人理解，并不确定是否正确：路子野)"></a>闭包的运行逻辑(个人理解，并不确定是否正确：路子野)</h3><ol>
<li>function a(){ n = 1; function a1(){ console.log(“hello”)} return a1}</li>
<li>b = a() c = a() //声明a函数 且赋值a()赋值于b,c变量</li>
<li>此时会再次生成两个内存空间存放b,c的闭包函数(a1)</li>
<li>由于a’.a1以及a’’.a1的存在也就是b,c的存在所以a’ 以及 a’’ 并不会被gc（辣鸡回收）</li>
<li>将内部变量保存在其中</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
</li>
<li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
</li>
<li><p>调用你的是WHO？</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/mobile-first-response-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/mobile-first-response-design/" itemprop="url">mobile-first-response-design</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-14T20:57:36+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="移动端设计如何做适配？"><a href="#移动端设计如何做适配？" class="headerlink" title="移动端设计如何做适配？"></a>移动端设计如何做适配？</h1><h2 id="1-mete-viewport"><a href="#1-mete-viewport" class="headerlink" title="1.mete viewport"></a>1.mete viewport</h2><blockquote>
<p>历史遗留问题宽度在没设计之前为980px,所以我们需要给手机上的页面重新定义一下。</p>
</blockquote>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, user-scalable=no, initial-scale=1.0, maximum-scale=1.0 minimum-scale=1.0&quot;&gt;
</code></pre><h2 id="2-media查询-响应式处理"><a href="#2-media查询-响应式处理" class="headerlink" title="2. media查询(响应式处理)"></a>2. media查询(响应式处理)</h2><blockquote>
<p>不同的媒体设备，或者不同的页面size或样式时对应不同的页面样式 两种方式使用。</p>
</blockquote>
<pre><code>1. style中直接定义
&lt;style&gt;
@media(max-width:800px){background: red;}
&lt;/style&gt;
2.link时定义
&lt;link type=&quot;text/css&quot; href=&quot;./style.css&quot;  media=&quot;(max-width: 500px)&quot; /&gt;
</code></pre><h2 id="3-动态rem方案"><a href="#3-动态rem方案" class="headerlink" title="3.动态rem方案"></a>3.动态rem方案</h2><blockquote>
<p>一般通过scss px 转换成 css 的rem 更加方便</p>
</blockquote>
<blockquote>
<p>Q： 为什么不使用百分比</p>
<blockquote>
<p>A: 因为百分比无法硬链接宽高 pass</p>
</blockquote>
</blockquote>
<blockquote>
<p>Q: em?</p>
<blockquote>
<p>A: no em是适用于当前元素的font-size若没有才继承爸爸的font-size，</p>
</blockquote>
</blockquote>
<blockquote>
<p>Q:rem?</p>
<blockquote>
<p>A:  yes rem 是适用于html的font-size，继承html</p>
</blockquote>
</blockquote>
<blockquote>
<p>Q:一个rem是多少？</p>
<blockquote>
<p>一个字的长度 or 一个 M 的长度..</p>
</blockquote>
</blockquote>
<blockquote>
<p>Q:HTML font-size?</p>
<blockquote>
<p>A: 它的默认font-size = 16px,chrome可以定义最小网页显示字的大小。</p>
</blockquote>
</blockquote>
<pre><code>//js
var pageWidth = window.innerWidth
document.write(&apos;&lt;style&gt;html{font-size: &apos; + pageWidth + &apos;px}&lt;/style&gt;&apos;)

//scss

@function px( $px ){
  @return $px/$designWidth*10 + rem;
}

$designWidth : 640; // 640 是设计稿的宽度。

.child{
  width: px(320);
  height: px(160);
  font-size: 1.2em;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/easy-jQuery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/easy-jQuery/" itemprop="url">easy-jQuery</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-13T12:06:06+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="easy-JQuery"><a href="#easy-JQuery" class="headerlink" title="easy - JQuery"></a>easy - JQuery</h2><blockquote>
<ol>
<li>jQuery 是一个JavaScript库</li>
<li>jQuery 能很大程度上简化JavaScript程序</li>
<li>jQuery 的学习非常简单</li>
</ol>
</blockquote>
<h3 id="Jquery-介绍"><a href="#Jquery-介绍" class="headerlink" title="Jquery 介绍"></a>Jquery 介绍</h3><blockquote>
<p>jQuery的目的就是让你在你的网站更容易的使用JavaScript</p>
</blockquote>
<blockquote>
<p>需要学习到的前置知识：</p>
</blockquote>
<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
</ul>
<blockquote>
<p>jQuery到底是什么？</p>
<blockquote>
<p>jQuery是一个轻量级的库，“write less, do more”,Javascript library</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p> jQuery的任务是通过大量的常见Javascript代码来完成 ，封装成方法后，你可以通过一行代码来使用</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>jQuery还简化了很多来自Javascript的东西，比如AJAX的调用和DOM的操作</p>
<blockquote>
<blockquote>
<p>AJAX = (ansyc JavaScript and XML)</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>jQuery库包含了下列的一下特征</p>
</blockquote>
</blockquote>
<ul>
<li>HTML/DOM 的操作方法</li>
<li>CSS 的操作方法</li>
<li>HTML事件方法</li>
<li>效果和动画</li>
<li>AJAX</li>
<li>工具</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此外，jQuery的plugins 几乎能完成所有任务</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么使用jQuery？</p>
<blockquote>
<p>有很多其他的Javascript框架，但jQuery似乎是最流行的，也是最可扩展的，许多大公司都在使用jQuery<br>比如：</p>
</blockquote>
</blockquote>
<ul>
<li>Google</li>
<li>Microsoft</li>
<li>IBM</li>
<li>Netflix</li>
</ul>
<blockquote>
<blockquote>
<p>tips: jQuery在所有主要浏览器的运行完全相同</p>
</blockquote>
</blockquote>
<h3 id="jQuery-开始！"><a href="#jQuery-开始！" class="headerlink" title="jQuery 开始！"></a>jQuery 开始！</h3><ul>
<li>你在jQuery.com可以下载jQuery库</li>
<li>你也可以include，从CDN上找到jQuery,比如谷歌</li>
</ul>
<blockquote>
<p>有两个版本的jQuery可以下载</p>
</blockquote>
<ul>
<li>生产版：这是给你的live website，因为它是压缩后的mini版本</li>
<li>开发版：这是为了测试和开发的版本（为被压缩的可读code）</li>
</ul>
<blockquote>
<p>这两个版本都能在jQuery.com上下载到</p>
</blockquote>
<blockquote>
<blockquote>
<p>jQuery是一个单独的JavaScript文件，所以我们要使用<script> Tag 来引用它(<script>标签应该在<head>中)</p>
</blockquote>
</blockquote>
<blockquote>
<p>tips: 也许你很惊讶我们在<script/>中没有type=”text/javascript”？</p>
<blockquote>
<p>这是因为在HTML5中这不是必须的，在HTML5中和现代浏览器中，Javascript是一个默认的脚本语言</p>
</blockquote>
</blockquote>
<blockquote>
<p>jQuery CDN</p>
<blockquote>
<p>如果你不想在自己的电脑上下载jQuery，你可以在CDN上包含它</p>
<blockquote>
<blockquote>
<p>CDN = content delivery network<br>在谷歌和微软的主机上引入jQuery<br>在Google或者Microsort上使用jQuery时你需要使用下面：</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<pre><code>GOOGLE CDN：
&lt;head&gt;&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js&quot;
&lt;/script&gt;
&lt;/head&gt;


Microsoft CDN：
&lt;head&gt;&lt;script src=&quot;https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.0.min.js&quot;&gt;
&lt;/script&gt;
&lt;/head&gt;
</code></pre><blockquote>
<p>tips： 一个引入Google or Microsoft的jQuery的一大优势</p>
<blockquote>
<p>很多用户从Google和Microsoft站点上下载了jQuery，它将直接从你访问站点时的缓存加载，这会很大程度的提高访问速度，并且，大多数CDN将确保一旦用户请求一个jQuery，jQuery将从服务器最上网络最近的服务器请求，这也会让你的访问速度提高</p>
</blockquote>
</blockquote>
<h2 id="jQuery语法"><a href="#jQuery语法" class="headerlink" title="jQuery语法"></a>jQuery语法</h2><blockquote>
<p>jQuery Syntax</p>
<blockquote>
<p>对于在元素上执行某一动作或选择某一HTML元素来说，jQuery的语法是特定的(tailor-mode)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>基础语法：$(selector).active()</p>
</blockquote>
</blockquote>
<ul>
<li>$ 符号  定义/访问 jQuery</li>
<li>(selector) 是”发现或者查询“HTML 元素</li>
<li>active() 让元素执行某一动作</li>
</ul>
<blockquote>
<blockquote>
<p>例子：</p>
</blockquote>
</blockquote>
<pre><code>$(this).hide() //隐藏当前元素
$(&apos;p&apos;).hide() // 隐藏所有p元素
$(&quot;.test&quot;).hide() // 隐藏class name 为 test的元素
$(&quot;#test&quot;).hide() // 隐藏id=&quot;test&quot;的元素
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>你熟悉CSS选择器吗？</p>
<blockquote>
<p>jQuery使用CSS选择器语法来选择元素，接下来你会学习到很多关于选择器的语法</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>你可能有注意到在jQuery例子中，所有jQuery method在一个document ready event 中</p>
</blockquote>
<pre><code>$(document).ready(function(){ 
    // jQuery methods go here...
});
</code></pre><ul>
<li>这是为了防止document加载结束之前运行jQuery code</li>
<li>这是一种good 做法，在文档加载前准备好它</li>
<li>这也允许你有其他的Javascript code</li>
</ul>
<blockquote>
<p>如果你不向上面那样做的话？</p>
</blockquote>
<ul>
<li>你要隐藏一个元素却还没有创建</li>
<li>你要改变一个图片大小却还没有加载好</li>
</ul>
<blockquote>
<p>tips: 上面甚至有一个shorter版本</p>
</blockquote>
<pre><code>$(function()){
    //jQuery method go here
}

第二种更简单，但第一种更容易理解
</code></pre><h3 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h3><blockquote>
<p>jQuery选择器是jQuery library中最重要的部分</p>
</blockquote>
<blockquote>
<p>jQuery选择器</p>
<blockquote>
<p>jQuery selectors 允许你选择或者操作HTML元素<br>jQuery选择器是通过HTML元素的name,id,classes,attributes,属性的值和其他更多的value来”find”or”select<br>它基于当前的CSS selectors和它的一些自定义选择器</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所有选择器的语法为:$()</p>
</blockquote>
</blockquote>
<blockquote>
<p>通过tagName选择元素</p>
<blockquote>
<p>jQuery通过元素的名字来选择元素，你能选择页面上所有的<p>元素：</p>
</blockquote>
</blockquote>
<pre><code>$(&quot;p&quot;)
</code></pre><blockquote>
<p>通过id选择元素</p>
<blockquote>
<p>jQuery通过#id 选择到属性为id的HTML 元素，获取到指定元素<br>id在页面中应该是unique的，所以在选择时查找到的元素只会的单独一个，它是独一无二的特殊元素<br>在通过指定id查找一个元素的时候，写一个哈希字符集</p>
</blockquote>
</blockquote>
<pre><code>$(document).ready(function(){ 
    $(&quot;button&quot;).click(function(){
        $(&quot;#test&quot;).hide();  
    });
});
</code></pre><blockquote>
<p>通过.class 选择器来选择元素</p>
<blockquote>
<p>jQuery .class 选择器来查询指定元素<br>通过指定class来找到元素，写一段字符集？？？例如：</p>
</blockquote>
</blockquote>
<pre><code>$(&quot;.test&quot;)

$(document).ready(function(){  
    $(&quot;button&quot;).click(function(){ 
        $(&quot;.test&quot;).hide();  
    });
});
</code></pre><p><a href="https://www.w3schools.com/jquery/jquery_selectors.asp">更多选择器的查询方法</a></p>
<h3 id="jQuery-Event-Methods"><a href="#jQuery-Event-Methods" class="headerlink" title="jQuery Event Methods"></a>jQuery Event Methods</h3><blockquote>
<p>jQuery在HTML页面专门设计了了响应事件</p>
</blockquote>
<blockquote>
<p>什么是事件？</p>
<blockquote>
<p>不同的user在网页上的行为我们称之为事件，做出相对的respond回应这种行为<br>一个事件代表某物在某时发生的精确操作 例子</p>
<blockquote>
<p>moving a mouse over an 元素<br>选择一个radio button<br>clicking on an element<br>在事件上我们常常使用”fires/fired”这个词语，“按键响应时间fired,当你按下一个键”<br>下面是一些常用的DOM events:<br>mouse events : click dblclick mouseenter mouseleave.<br>keyboard events: keypress , keydown , keyup<br>form Events: submit , change, focus, blur.<br>document/ windows events: load resize , scroll, unload.</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>jQuery 语法 For Event Methods</p>
<blockquote>
<p>在jQuery中，很多的DOM事件等同于，jQuery方法<br>给所有的段落<p/>标签分配一个click事件。列子：</p>
</blockquote>
</blockquote>
<pre><code>$(&quot;p&quot;).click();
</code></pre><blockquote>
<blockquote>
<p>你如果想通过一个函数事件定义，当发生这个事件时，应该要发生什么，例子</p>
</blockquote>
</blockquote>
<pre><code>$(&quot;p&quot;).click(function(){  
         // action goes here!!
} );
</code></pre><blockquote>
<p>常用的jQuery事件方法</p>
</blockquote>
<ul>
<li><p>(document).ready()</p>
<blockquote>
<p>这个函数允许你在document完全加载好后执行</p>
</blockquote>
</li>
<li><p>click()</p>
<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>函数在HTML元素被点击时候执行<br>下面这个例子是说，当点击这个p元素的时候，隐藏它</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;p&quot;).click(function(){
    $(this).hide();
});
</code></pre><ul>
<li>dblclick()<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>在双击HTML 元素的时候会执行这个方法</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;p&quot;).dblclick(function(){ 
    $(this).hide();
});
</code></pre><ul>
<li>mouseenter()<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>当鼠标指向这个HTML元素时会触发这个事件函数</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;#p1&quot;).mouseenter(function(){
        alert(&quot;You entered p1!&quot;);
});
</code></pre><ul>
<li>mouseleave()<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>当鼠标离开指向的这个元素时会触发这个事件函数</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;#p1&quot;).mouseleave(function(){ 
    alert(&quot;Bye! You now leave p1!&quot;);
    });
</code></pre><ul>
<li>mousedown()<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>当鼠标按下(左键，右键或者滚轮键)的时候，会触发这个事件函数</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;#p1&quot;).mousedown(function(){ 
    alert(&quot;Mouse down over p1!&quot;);
    });
</code></pre><ul>
<li>mouseup()<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>鼠标点击后离开会触发的事件</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;#p1&quot;).mouseup(function(){  
    alert(&quot;Mouse up over p1!&quot;);
    });
</code></pre><ul>
<li>hover()<blockquote>
<p>这个方法在一个HTML元素上绑定了一个事件处理函数<br>鼠标移动到HTML元素会触发的事件，第一个函数为enter元素的时候，第二个为leave元素的时候</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;#p1&quot;).hover(function(){
     alert(&quot;You entered p1!&quot;);
    },function(){ 
      alert(&quot;Bye! You now leave p1!&quot;);
    });
</code></pre><ul>
<li>focus()<blockquote>
<p>这个方法在一个HTML表单字段上绑定了一个事件处理函数<br>当聚焦于某一个表单字段的时候会触发这个函数</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;input&quot;).focus(function(){  
    $(this).css(&quot;background-color&quot;, &quot;#cccccc&quot;);
});
</code></pre><ul>
<li>blur()<blockquote>
<p>这个方法在一个HTML表单字段上绑定了一个事件处理函数<br>当丢失聚焦后会触发这个函数</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;input&quot;).blur(function(){
     $(this).css(&quot;background-color&quot;, &quot;#ffffff&quot;);
});
</code></pre><ul>
<li>The on() 方法<blockquote>
<p>on() 方法对于选择到的元素来说，绑定了一个或者多个事件处理函数<br>例如</p>
</blockquote>
</li>
</ul>
<pre><code>$(&quot;p&quot;).on(&quot;click&quot;, function(){ 
    $(this).hide();
    });
</code></pre><p>或者</p>
<pre><code>$(&quot;p&quot;).on({ 
  mouseenter: function(){
     $(this).css(&quot;background-color&quot;, &quot;lightgray&quot;); 
  },   
  mouseleave: function(){ 
      $(this).css(&quot;background-color&quot;, &quot;lightblue&quot;);  
  },   click: function(){ 
         $(this).css(&quot;background-color&quot;, &quot;yellow&quot;);  
    } 
});
</code></pre></script></p></blockquote></blockquote>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/HTML-DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leeyw">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeeywBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/HTML-DOM/" itemprop="url">HTML-DOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-06T22:02:54+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="认识DOM"><a href="#认识DOM" class="headerlink" title="认识DOM"></a>认识DOM</h1><h2 id="DOM-基础"><a href="#DOM-基础" class="headerlink" title="DOM 基础"></a>DOM 基础</h2><blockquote>
<p>When a web page is loaded, the browser creates a Document Object Model of the page.The HTML DOM model is constructed as a tree of Objects:<br>译: 当加载一个网页的时，浏览器会创建一个由文档、对象、模式组成的页面，这个HTML DOM 构造了一个对象树</p>
</blockquote>
<blockquote>
<p>What You Will Learn?<br>Change to HTML elements and Style(CSS) and lesten to DOM event and add or  delete HTML element<br>DOM is a W3C standard,that is define for  accessing documents</p>
</blockquote>
<blockquote>
<p>What is the HTML DOM?<br>The HTML DOM is a standard object model and programming interface  for HTML . it define:<br>HTML element as Object<br>all properties in HTML element<br>thet events for all HTML element<br>the methods to access all HTML element</p>
</blockquote>
<h2 id="HTML-DOM-的方法"><a href="#HTML-DOM-的方法" class="headerlink" title="HTML DOM 的方法"></a>HTML DOM 的方法</h2><blockquote>
<p>HTML DOM 方法是一个可以执行的动作(在HTML element中)<br>HTML DOM 属性是一个value(在HTML element中) 所以可以设置或者改变它</p>
</blockquote>
<blockquote>
<p> about DOM Programming Interface .<br> HTML DOM 用Javascript或者其他的编程语言进行访问<br> 在DOM中，所有的html元素都是Object<br> 编程接口是每个对象的属性和methods<br> property是一个value你可以get or set 这个value<br> method 是一个动词，你可以对HTMl元素进行添加和删除<br>例子：<br>    &lt;!DOCTYPE html&gt;<br>    <html><br>    <body><br>    <h2>My First Page</h2></body></html></p>
</blockquote>
<pre><code>&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;

&lt;script&gt;
document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello World!&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h2&gt;My First Page&lt;/h2&gt;

&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;

&lt;script&gt;
document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello World!&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><blockquote>
<p>在上面例子中，<strong>getElementById</strong> 是一个方法，但是在HTML中，它是一个属性</p>
</blockquote>
<blockquote>
<p>The<strong> getElementById</strong> Method 是最常见的访问HTMl中页面元素的方式。<br>上面的例子中getElementById 方法使用 id=”demo”寻找到元素</p>
</blockquote>
<blockquote>
<p><strong>innerHTML</strong>属性是最简单获取元素中内容的方法<br><strong>innerHTML</strong> property 可以很有效的获取或者改变页面元素内容</p>
<blockquote>
<p>innerHTML可以改变任何HTML element的内容，包括<body> 和 <html></html></body></p>
</blockquote>
</blockquote>
<h2 id="The-HTML-DOM-Document"><a href="#The-HTML-DOM-Document" class="headerlink" title="The HTML DOM Document"></a>The HTML DOM Document</h2><blockquote>
<p>HTML DOM Document Object 是你Web page中所有其他对象的所有者(爸爸)</p>
</blockquote>
<blockquote>
<p>About HTML DOM Document</p>
<ol>
<li>document Object 就是你的web page</li>
<li>如果你想访问你web page的任何元素，你都是从document Object开始的<br>3.下面的一些例子将会告诉你操作和访问HTML的办法</li>
</ol>
</blockquote>
<blockquote>
<p> 寻找 HTML Elements ?</p>
</blockquote>
<pre><code>Method
document.getElementById(id) //通过元素id寻找元素

document.getElementsByTagName(name)//通过标签名字寻找元素s

document.getElementsByClassName(name)//通过class的名字寻找元素s
</code></pre><blockquote>
<p>改变页面元素？ </p>
</blockquote>
<pre><code>Property

element.innerHTML =  new html content //更改元素内容

element.attribute = new value//更改元素属性值    

element.style.property = new style //更改元素的style(CSS)

Method
element.setAttribute(attribute, value)//改变元素的属性值
</code></pre><blockquote>
<p>添加和删除元素？</p>
</blockquote>
<pre><code>Method    
document.createElement(element)//创建一个HTML元素

document.removeChild(element)//移除一个HTML元素儿子

document.appendChild(element)//添加一个元素儿子

document.replaceChild(new, old)//替换一个元素儿子

document.write(text)//Write into the HTML output stream
</code></pre><blockquote>
<p>添加一个事件处理函数？</p>
</blockquote>
<pre><code>Method 
document.getElementById(id).onclick = function(){code} //添加一个事件处理程序，code中为onclick 事件
</code></pre><blockquote>
<p>Finding HTML 对象 ?<br>第一版的HTML DOM 只定义了11个HTML 对象，对象集合和性质。这是在HTML5中仍然有效的，后来有了第三版的HTML DOM 添加了很多的对象，集合以及性质<br><img src="en-resource://database/1306:1" alt="a9cfd0a63e16b169ff2f19d00d005c88.png"></p>
</blockquote>
<h2 id="JavaScript-HTML-DOM-元素"><a href="#JavaScript-HTML-DOM-元素" class="headerlink" title="JavaScript HTML DOM 元素"></a>JavaScript HTML DOM 元素</h2><blockquote>
<p>这将教你如何查找访问到一个page中的element</p>
</blockquote>
<blockquote>
<p>查找HTML 页面元素<br> 通常你会想使用JavaScript操作HTML的元素<br> To do so， 你首先得找到element，有几种办法可以实现：</p>
</blockquote>
<pre><code>寻找页面元素 By （Id ，Tag name, Class name, Css selectors , HTML Object Collections） 
</code></pre><blockquote>
<p>通过Id 寻找页面元素</p>
<blockquote>
<p>这是寻找页面元素最简单的办法。例如：</p>
</blockquote>
</blockquote>
<pre><code>var myElement = document.getElementById(&quot;intro&quot;);
</code></pre><blockquote>
<p>如果寻找到了元素，则会返回一个元素作为对象，如果没有找到，则会返回null</p>
</blockquote>
<blockquote>
<p>通过标签名字找元素</p>
</blockquote>
<pre><code>var x = document.getElementsByTagName(&quot;p&quot;);
</code></pre><blockquote>
<p>通过类名找元素</p>
</blockquote>
<pre><code>var x = document.getElementsByClassName(&quot;intro&quot;);
</code></pre><blockquote>
<p>通过Css选择器找元素</p>
<blockquote>
<p>如果你想找到所有指定的HTML元素的CSS选择器(id,class names, types, attributes, value of attributes, etc ),则可以使用querySelectorAll()方法</p>
</blockquote>
</blockquote>
<pre><code>var x = document.querySelectorAll(&quot;p.intro&quot;);
</code></pre><blockquote>
<p>querySelectorAll()不支持IE8以及之前版本，ie果然是辣鸡</p>
</blockquote>
<blockquote>
<p>通过对象集 来找元素<br>例子：通过发现表单id为frm1的元素，再遍历元素中的值获取后innerHTML添加内容</p>
</blockquote>
<pre><code>var x = document.forms[&quot;frm1&quot;];
var text = &quot;&quot;;
var i;
for (i = 0; i &lt; x.length; i++) {
    text += x.elements[i].value + &quot;&lt;br&gt;&quot;;
}
document.getElementById(&quot;demo&quot;).innerHTML = text;
</code></pre><blockquote>
<p>下面的HTML Object和对象集 也可以访问进入使用</p>
</blockquote>
<pre><code>document.anchors
document.body
document.documentElement
document.embeds
document.forms
document.head
document.images
document.links
document.scripts
document.title
</code></pre><h2 id="JavaScript-HTML-DOM-Changing-HTML"><a href="#JavaScript-HTML-DOM-Changing-HTML" class="headerlink" title="JavaScript HTML DOM - Changing HTML"></a>JavaScript HTML DOM - Changing HTML</h2><blockquote>
<p>HTML DOM 允许JavaScript 改变page element 内容</p>
</blockquote>
<blockquote>
<p>改变HTML的输出流<br>Javascript 能创建 dynamic(动态) 的html内容，通过document.write()直接作为HTML 的输出流<br>例子：输出时间</p>
</blockquote>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
document.write(Date());
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><blockquote>
<p>注意在加载文档之后不要使用document.write()，这会覆盖之前的文档内容</p>
</blockquote>
<blockquote>
<p>改变HTML内容<br>使用inner HTML来修改HTML Element 的content 是 easiest way<br> syntax(语法):</p>
</blockquote>
<pre><code>document.getElementById(id).innerHTML = new HTML
</code></pre><blockquote>
<p>改变属性的值<br>改变HTML属性值的语法:</p>
</blockquote>
<pre><code>document.getElementById(id).attribute = new value


&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;     &lt;img id=&quot;myImage&quot; src=&quot;smiley.gif&quot;&gt;
&lt;script&gt;                  document.getElementById(&quot;myImage&quot;).src = &quot;landscape.jpg&quot;;       &lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre><h2 id="JavaScript-HTML-DOM-Changing-CSS"><a href="#JavaScript-HTML-DOM-Changing-CSS" class="headerlink" title="JavaScript HTML DOM - Changing CSS"></a>JavaScript HTML DOM - Changing CSS</h2><blockquote>
<p>HTML DOM 允许JavaScript改变HTML elements的Style</p>
</blockquote>
<blockquote>
<p>改变HTML 的Style<br>我们要改变HTML元素风格的使用的语法:</p>
</blockquote>
<pre><code>document.getElementById(id).style.property = new style
</code></pre><blockquote>
<p>通过下面的例子来改变元素p的Style</p>
</blockquote>
<pre><code>&lt;html&gt;&lt;body&gt;
&lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;
&lt;script&gt;
document.getElementById(&quot;p2&quot;).style.color = &quot;blue&quot;;
&lt;/script&gt;
&lt;p&gt;The paragraph above was changed by a script.&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre><blockquote>
<p>利用事件</p>
<blockquote>
<p>HTML DOM 允许你在事件发生时执行代码<br>事件是HTML元素在浏览器上”things happen”(事件发生)时生成的</p>
</blockquote>
</blockquote>
<ul>
<li>元素的点击</li>
<li>页面的加载</li>
<li>字段的改变</li>
</ul>
<blockquote>
<p>你会了解很多的事件<br>下面这个例子改变了HTML Element Style 对于id=”id1”的标签，(在点击这个按钮时</p>
</blockquote>
<pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;
&lt;h1 id=&quot;id1&quot;&gt;My Heading 1&lt;/h1&gt;
&lt;button type=&quot;button&quot; 
onclick=&quot;document.getElementById(&apos;id1&apos;).style.color = &apos;red&apos;&quot;&gt;Click Me!
&lt;/button&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre><blockquote>
<p>上面这个例子讲事件封装在button中</p>
</blockquote>
<h2 id="JavaScript-HTML-DOM-Animation"><a href="#JavaScript-HTML-DOM-Animation" class="headerlink" title="JavaScript HTML DOM Animation"></a>JavaScript HTML DOM Animation</h2><blockquote>
<p>了解如何使用Javascript创建HTML动画</p>
</blockquote>
<blockquote>
<p>一个基础的web页面中，所有的动画应当都基于一个容器<br>分别创建容器样式的风格，以及动画样式的Style<br>动画通过计时器控制，若计时器间隔够小则会让动画看起来十分连续</p>
</blockquote>
<pre><code>var id = setInterval(frame, 5);
function frame() {  
if (/* test for finished */) {  
</code></pre><ul>
<li><p>clearInterval(id);  </p>
<p>} else {<br>/<em> code to change the element style </em>/<br>}<br>}</p>
<blockquote>
<p>动画执行顺序</p>
</blockquote>
</li>
<li><p>获取动画标签对象</p>
</li>
<li>设置一个源点(计时)</li>
<li>设置间隔(frame,5)参数1是动作，参数2是间隔</li>
<li>设置一个动作函数，并设置出点(否则会死循环),若完成动作则使用clearInterval(id)退出，id为setInterval(1,2)的对象</li>
<li>此时一个简单动画完成</li>
<li>安利一个tween.js的外部库</li>
</ul>
<h2 id="JavaScript-HTML-DOM-Events"><a href="#JavaScript-HTML-DOM-Events" class="headerlink" title="JavaScript HTML DOM Events"></a>JavaScript HTML DOM Events</h2><blockquote>
<p>HTML DOM 允许JavaScript对于事件做出反应</p>
</blockquote>
<blockquote>
<p>对事件做出反应？<br>当用户点击HTML Elements 时候JavaScript能通过code执行做出相应的反应</p>
</blockquote>
<blockquote>
<p>HTML  事件的例子</p>
</blockquote>
<ul>
<li>点击鼠标</li>
<li>页面加载</li>
<li>图片加载</li>
<li>鼠标移动到某个元素</li>
<li>表单提交</li>
<li>敲击键盘</li>
</ul>
<blockquote>
<p>我们可以通过封装事件在标签中，或者script的函数中来实现监听效果</p>
</blockquote>
<blockquote>
<p>可以通过分配事件属性给HTML元素<br>分配一个onclick事件给一个按钮元素</p>
</blockquote>
<pre><code>&lt;button onclick=&quot;displayDate()&quot;&gt;Try it&lt;/button&gt;
</code></pre><blockquote>
<p>指定使用HTML DOM 事件<br>HTML DOM 允许你使用JavaScript事件分配给HTML元素<br>例如，我们指定一个onclick事件给按钮元素</p>
</blockquote>
<pre><code>&lt;script&gt;
document.getElementById(&quot;myBtn&quot;).onclick = displayDate;&lt;/script&gt;
</code></pre><blockquote>
<p>上述例子为，将分配一个onclick事件给id为MyBth的标签对象在点击时执行名为displayDate的函数</p>
</blockquote>
<blockquote>
<p>加载页面和离开页面事件 onload and onunload events<br>这两个事件在进入和离开page时发生<br>onload 可以用来检测访问者浏览器的版本的类型，然后加载对应的版本信息渲染在web page<br>这两个函数也可以用来处理cookies<br>例子：<br>    <body onload="checkCookies()"></body></p>
</blockquote>
<blockquote>
<p>onchange 事件<br>onchange 事件常常使用在输入字段的验证</p>
</blockquote>
<pre><code>&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;upperCase()&quot;&gt;
</code></pre><blockquote>
<p>上述例子中，通过在script中使用toUpperCase() 将小写转换成大写</p>
</blockquote>
<blockquote>
<p>onmouseover and onmouseout 会在鼠标在标签对象上或离开标签对象上时发生</p>
</blockquote>
<blockquote>
<p>onmousedown and onmouseup and onclick 事件是所有的mouse-click，第一个会在鼠标点击的时候发生，第二个会在鼠标释放的时候发生，第三个会在鼠标点击完成后发生</p>
</blockquote>
<h2 id="JavaScript-HTML-DOM-EventListener"><a href="#JavaScript-HTML-DOM-EventListener" class="headerlink" title="JavaScript HTML DOM EventListener"></a>JavaScript HTML DOM EventListener</h2><blockquote>
<p> 添加一个监听方法<br> The addEventListener() method</p>
</blockquote>
<pre><code>//当用户点击按钮的时候触发时间监听   document.getElementById(&quot;myBth&quot;).addEventListener(&quot;click&quot;,displayDate)
</code></pre><blockquote>
<p>1.addEventListener()将时间处理程序添加到指定的元素上</p>
<p>2.且它不会覆盖已有的事件处理程序</p>
<p>3.你可以给除了HTML 元素的其他元素如windows object等某一元素添加多个处理事件（也可以是同一触发条件触发的多个事件处理程序）</p>
<p>4.它同样可以更容易的处理和控制事件的冒泡行为</p>
<p>5.使用它的时候可以为你带来更好的可读性，且JavaScript于HTML标记分离开处理，允许你添加事件监听，即便你不控制HTML的标记</p>
<p>6.你可以使用它更简单的移除掉事件监听 通过removeEventListener()</p>
</blockquote>
<p>Syntax:   </p>
<pre><code>element.addEventListener(event, function, useCapture);
</code></pre><p>first parameter : 事件类型，”click” or “mousedown”..<br>secand parameter : 处理函数<br>third parameter : 是否指定冒泡捕获，用Boolean value 确定，可选参数</p>
<blockquote>
<p>onclick != click<br>click 是对象的方法，  onclick是事件，<br>我们在点击按钮时会先执行onclick 然后执行click，因为onclick是点击事件，首先触发事件，然后触发事件的点击方法，<br>得出，我们即便不添加点击方法(click) 也会触发点击事件~~~</p>
</blockquote>
<blockquote>
<p>给一个元素添加一个事件处理程序</p>
</blockquote>
<blockquote>
<p>让一个元素在触发点击方法的时候弹出“hello world”的alert</p>
</blockquote>
<pre><code>element.addEventListener(&quot;click&quot;, function(){ alert(&quot;Hello World!&quot;); });
</code></pre><blockquote>
<p>当然 ，你也可以引用外部函数</p>
</blockquote>
<pre><code>element.addEventListener(&quot;click&quot;, myFunction);
function myFunction() {
alert (&quot;Hello World!&quot;);
}
</code></pre><blockquote>
<p>给同一个元素添加多个事件处理程序</p>
</blockquote>
<pre><code>element.addEventListener(&quot;click&quot;, myFunction);
element.addEventListener(&quot;click&quot;, mySecondFunction);
</code></pre><blockquote>
<p>此时会按照程序顺序依次执行事件处理程序</p>
</blockquote>
<blockquote>
<p>将不同类型的处理函数添加到同一元素中</p>
</blockquote>
<pre><code>element.addEventListener(&quot;mouseover&quot;, myFunction);
element.addEventListener(&quot;click&quot;, mySecondFunction);
element.addEventListener(&quot;mouseout&quot;, myThirdFunction);
</code></pre><blockquote>
<p>在window object上添加事件处理程序</p>
<blockquote>
<p>你可以在任何HTML DOM 上使用addEventListener()添加事件监听处理，(如：xmlHttpRequest Object</p>
</blockquote>
</blockquote>
<blockquote>
<p>用户改变窗口大小时的事件监听</p>
</blockquote>
<pre><code>window.addEventListener(&quot;resize&quot;, function(){  
document.getElementById(&quot;demo&quot;).innerHTML = sometext;
});
</code></pre><blockquote>
<p>传递参数<br>在用户触发事件时可做传递参数的函数使用</p>
</blockquote>
<pre><code>element.addEventListener(&quot;click&quot;, function(){ myFunction(p1, p2); });
</code></pre><blockquote>
<p>事件的冒泡和捕获？</p>
<blockquote>
<p>HTML DOM 中有两种方式传递事件，1. 冒泡 2.捕获<br>事件的传播是一种定义元素发生时事件时顺序的的方法？？<br>例如：<div>中<p>的click被点击，先触发那个的click？</p>
</div></p></blockquote>
</blockquote>
<blockquote>
<p>所以我们可以通过第三个参数来控制，当为false时则采用冒泡，</p>
</blockquote>
<blockquote>
<p>若为ture时 则采用捕获</p>
</blockquote>
<pre><code>document.getElementById(&quot;myP&quot;).addEventListener(&quot;click&quot;, myFunction, true);
document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, myFunction, true);
</code></pre><blockquote>
<p>可以通过removeEventListener()来移除已有的处理程序</p>
</blockquote>
<h2 id="DOM-Nodes"><a href="#DOM-Nodes" class="headerlink" title="DOM Nodes"></a>DOM Nodes</h2><blockquote>
<p>根据W3C标准，一切东西在HTML document中都是一个Node(节点)</p>
</blockquote>
<ul>
<li>文档是文档节点</li>
<li>所有的元素是元素节点</li>
<li>在HTML 元素中的文本是文本节点</li>
<li>所有的属性是属性节点（弃用）</li>
<li>所有的注释都是注释节点</li>
</ul>
<blockquote>
<p>JavaScript能访问所有存在于节点数中的节点<br> 可以对节点进行增删改的操作 </p>
</blockquote>
<blockquote>
<p>节点之间的关系</p>
</blockquote>
<blockquote>
<p>显而易见，结点之间有着层级关系</p>
<p>他们之间通过，parent,child,sibling来组成的关系网</p>
</blockquote>
<ul>
<li>在节点树种，最顶上的节点就是root，称为根节点</li>
<li>除根节点之外，所有的节点都有一个爸爸节点parent</li>
<li>一个节点可以有很多的子节点</li>
<li>siblings 有相同的parent</li>
</ul>
<blockquote>
<p>节点与节点之间的跳转，导航</p>
<blockquote>
<p>JavaScript可以使用以下一些属性在节点直接跳转</p>
</blockquote>
</blockquote>
<ul>
<li>parentNode//爸爸节点</li>
<li>childNodes[nodenumber] //儿子们节点</li>
<li>firstChild //第一个儿子节点</li>
<li>lastChild//最后一个儿子节点</li>
<li>nextSibling //下一个兄弟节点</li>
<li>perviousSibling//上一个兄弟节点</li>
<li>小操作：获取到你爸爸节点的儿子们节点，排除自己就能获取到所有的兄弟节点辣</li>
</ul>
<blockquote>
<p>子节点和节点值<br>DOM 经常会让你想获取的期望节点种含有文本<br>元素节点中的文本节点可以通过innerHTML访问<br>innerHTML方法和访问元素节点的第一个子节点的nodeValue的值一样<br>或者直接使用childNodes[0].nodeValue 的结果一样</p>
</blockquote>
<blockquote>
<p>nodeName Property总是会返回一个大写的tag name<br>nodeValue 返回一个指定节点的值</p>
</blockquote>
<ul>
<li>如果是一个元素节点则返回null</li>
<li>如果是一个文本节点则返回文本</li>
<li>如果是一个属性节点，则返回属性的值</li>
</ul>
<blockquote>
<p>nodeType Property 返回节点的类型</p>
</blockquote>
<ul>
<li>ELEMENT_NODE   === 1</li>
<li>ATTRIBUTE_NODE  === 2</li>
<li>TEXT_NODE === 3</li>
<li>COMMENT_NODE === 8 </li>
<li>DOCUMENT_NODE === 9</li>
<li>DOCUMENT_TYPE_NODE === 10</li>
</ul>
<h2 id="JavaScript-HTML-DOM-Element-Nodes"><a href="#JavaScript-HTML-DOM-Element-Nodes" class="headerlink" title="JavaScript HTML DOM Element(Nodes)"></a>JavaScript HTML DOM Element(Nodes)</h2><blockquote>
<p>添加或者删除元素节点</p>
</blockquote>
<blockquote>
<p>创建一个新的元素节点首先需要创建一个元素，然后将这个元素添加到已有的元素当中去</p>
</blockquote>
<pre><code>document.createElement(TagName)
document.createTextNode(TextContent)
appendChild(Node)
element.appendChild(NodeElement)
</code></pre><blockquote>
<p>创建一个新的元素—-&gt;insertBefore()</p>
<blockquote>
<p>appendChild()方法在上面的列子中，添加了一个新的元素在parent的last Children<br>如果你不想那样，则可以使用insertBefore()方法<br>parent.insertBefore(newNode,child)//将newNode节点添加到child之前</p>
</blockquote>
</blockquote>
<blockquote>
<p>删除一个已有的元素<br>删除一个已有的元素，你首先得知道它的父亲元素</p>
</blockquote>
<pre><code>var parent = document.getElementById(&quot;div1&quot;);
var child = document.getElementById(&quot;p1&quot;);
parent.removeChild(child);
</code></pre><blockquote>
<p>//IE所有的版本都不兼容node.remove()方法 </p>
</blockquote>
<blockquote>
<p>替换某个元素</p>
<blockquote>
<p>如果你要在HTML DOM中替换某个元素，就使用replaceChild() 方法<br>first find parent element then find 你要替换的元素，然后通过你已经创建好的新元素使用replaceChild(para,child)来替换</p>
</blockquote>
</blockquote>
<pre><code>var para = document.createElement(&quot;p&quot;);
var node = document.createTextNode(&quot;This is new.&quot;);
para.appendChild(node);
var parent = document.getElementById(&quot;div1&quot;);
var child = document.getElementById(&quot;p1&quot;);
parent.replaceChild(para, child);
</code></pre><h2 id="JavaScript-HTML-DOM-Colection"><a href="#JavaScript-HTML-DOM-Colection" class="headerlink" title="JavaScript HTML　DOM　Colection"></a>JavaScript HTML　DOM　Colection</h2><blockquote>
<p>对于HTMLCollection 对象</p>
<blockquote>
<p>对于getElementByTagName()方法，他会return一个HTMLCollection对象<br>一个HTMLCollection 对象是一个在HTML Element中的一个类似数组的列表（collection）</p>
</blockquote>
</blockquote>
<p>Example:</p>
<pre><code>var x = document.getElementByTagName(Tag)
</code></pre><blockquote>
<p>我们可以使用index number来访问collection的元素<br>例如 访问第二个tag元素我们可以这样写：</p>
</blockquote>
<pre><code>y = x[1]//index number 从 0 开始
</code></pre><blockquote>
<p>HTML 中HTMLCollection 的长度</p>
<blockquote>
<p>对于length属性是在colection中的元素数量</p>
</blockquote>
</blockquote>
<pre><code>   var myCollection = document.getElementsByTagName(&quot;p&quot;);
document.getElementById(&quot;demo&quot;).innerHTML = myCollection.length;

1. 创建一个p的collection
2. 获取到collection的长度
</code></pre><blockquote>
<p>长度的作用 可以让你loop完所有的元素  好用的一匹</p>
</blockquote>
<pre><code>var myCollection = document.getElementsByTagName(&quot;p&quot;);
var i;
for (i = 0; i &lt; myCollection.length; i++) {  
myCollection[i].style.backgroundColor = &quot;red&quot;;
}
</code></pre><blockquote>
<p>An HTMLCollection is NOT an array!<br>HTML collection 不是不是不是一个数组啊啊啊！！<br>它看起来像，但它不是<br>你可以遍历列表和get单个元素，这让他看起来像一个数组<br>然鹅，你不能在HTMLCollection上使用Array的方法<br>push pop valueOf join …. 这些都不行</p>
</blockquote>
<h2 id="JavaScript-HTML-DOM-Node-Lists"><a href="#JavaScript-HTML-DOM-Node-Lists" class="headerlink" title="JavaScript HTML DOM Node Lists"></a>JavaScript HTML DOM Node Lists</h2><blockquote>
<p>关于HTML DOM Nodelist 对象</p>
</blockquote>
<ul>
<li>NodeList 对象是一个List(collection)它从document中提取出来</li>
<li>NodeList 对象几乎等同于HTMLCollection 对象</li>
<li>一些浏览器会返回NodeList对象来代替HTMLCollection对象对于getElementByClassName()方法</li>
<li>所有浏览器使用childNodes方法都会返回NodeList对象</li>
<li>大部分的浏览器使用querySelectorAll()方法会返回一个NodeList对象</li>
</ul>
<blockquote>
<p>HTML DOM Node List Length<br>MyNodelist.length</p>
</blockquote>
<blockquote>
<p>HTMLCollection 和 NodeList 有什么不同</p>
</blockquote>
<ol>
<li>HTMLCollection是collection的HTML元素</li>
<li>NodeList是collection的Document节点</li>
<li>NodeList和HTML collection有很多相同的东西(功能)</li>
<li>HTMLCollection和NodeList都是类似数组的集合</li>
<li>两者都有length，用于记录列表中的item数目</li>
<li>两个都提供了index(0,1,2,3,4..)访问</li>
<li>可以通过items name id 来访问HTMLCollection</li>
<li>NodeList只能通过索引访问</li>
<li>只有NodeList含有属性节点和文本节点</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Leeyw</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leeyw</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
